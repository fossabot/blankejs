Entity
	game object that can have hitboxes/collisions and sprite animations
	collisions use HardonCollider
]]

-- init code generated by IDE
BlankE.addClassType("entity_name", "Entity")

-- instance properties
num x, y
str sprite_index
num	sprite_width, sprite_height
num sprite_angle					-- in degrees
num sprite_xscale, sprite_yscale	-- 1 = normal scaling, -1 = flip
num sprite_xoffset, sprite_yoffset
num sprite_xshear, sprite_yshear
num sprite_color[r, g, b]			-- blend color for sprite. default = 255(white)
num sprite_alpha					-- default = 255
num sprite_speed					-- default = 1
num sprite_frame					-- TODO: doesn't work

num direction						-- in degrees
num friction
num gravity
num gravity_direction				-- in degrees. 0 = right, 90 = down, default = 90
num hspeed, vspeed
num speed 							-- best used with 'direction'
num xprevious, yprevious			-- location during last update loop
num xstart, ystart					-- location when object is first created. not always 0,0

{} net_sync_vars					-- variables to be synced by the Net library
bool show_debug

-- overridable methods
preUpdate(dt)
update(dt)							-- caution: controls all physics/motion/position variables
postUpdate(dt)
preDraw()
draw()								-- caution: controls sprite, animation
postDraw()

-- regular methods
debugSprite()						-- green: call during drawing (ex. state:draw)
debugCollision()					-- red: shows hitboxes		
addAnimation{...}					--[[
	name = str
	image = str 					-- name of asset (ex. bob_stand, bob_walk)
	frames = {...}					-- {'1-2', 1} means columns 1-2 and row 1
	frame_size = {width, height}	-- {32,32} means each frame is 32 by 32
	speed = float					-- 0.1 smaller = faster
	offset = {x, y}
]]
drawSprite(sprite_index)			-- calls default draw function for given animation name
addShape(...)						--[[
	name - str
	shape - str rectangle, circle, polygon, point
	dimensions - {...}
		- rectangle {left, top, width, height}
		- circle {center_x, center_y, radius}
	}
]]
setMainShape(name)
removeShape(name)					-- disables a shape. it is still in the shapes table however and will be replaced using addShape(same_name)
distancePoint(x ,y)				-- entity origin distance from point
distance(other_entity)
moveTowardsPoint(x, y, speed)		-- sets direction and speed vars
containsPoint(x, y)				-- checks if a point is inside the sprite (not hitboxes)

-- special collision methods
func onCollision{name}
func collisionStopX()
func collisionStopY()

-- platformer collisions example
function entity0:init()
	self.gravity = 30
	self.can_jump = true
	self.k_left = Input('left', 'a')
	self.k_right = Input('right', 'd')
	self.k_jump = Input('up', 'w')

	self:addShape("main", "rectangle", {0, 0, 32, 32})		-- rectangle of whole players body
	self:addShape("jump_box", "rectangle", {4, 30, 24, 2})	-- rectangle at players feet
	self:setMainShape("main")								-- dont forget this! Used to figure out where to place the sprite
end

function entity0:update(dt)
	self.onCollision["main"] = function(other, sep_vector)	-- other: other hitbox in collision
		if other.tag == "ground" then
			-- ceiling collision
            if sep_vector.y > 0 and self.vspeed < 0 then
                self:collisionStopY()
            end
            -- horizontal collision
            if math.abs(sep_vector.x) > 0 then
                self:collisionStopX() 
            end
		end
	end

	self.onCollision["jump_box"] = function(other, sep_vector)
        if other.tag == "ground" and sep_vector.y < 0 then
            -- floor collision
            self.can_jump = true 
        	self:collisionStopY()
        end 
    end

    if self.k_right() and not self.k_left() then
    	self.hspeed = 180
    end

    if self.k_left() and not self.k_right() then
    	self.hspeed = 180
    end

    if self.k_up() then
    	self:jump()
    end
end

function entity0:jump()
	if self.can_jump then
        self.vspeed = -700
        self.can_jump = false
    end	
end